# Lec1 C++语言概述
## C++与C的关系
C++包含了C的所有成分,在C的基础上增加了一些新的语言机制
## C++对C的基本扩充
* 局部变量的定义位置：允许局部变量的定义可以夹插在语句中
* 常量定义：
```c
#define PI 3.1416
```
C的做法，编译预处理命令
```cpp
const double PI=3.1416;
```
C++的做法，便于编译时进行类型检查
* 表示条件的表达式:
值非0表示满足，0表示不满足（C的做法）
bool类型：true表示满足，false表示不满足（C++扩充的，便于理解）
* 内联（inline）函数
* 名空间（namespace）
* 标准库
* 动态变量的内存分配
* 引用类型
* 函数名重载
* 类型自动判断auto
* 结构化异常处理
* 类型安全的输入输出

### 类型安全的输入输出
假设现在有变量x,y:
```c
int x;
double y;
```
c语言的输入输出：
```c
#include <stdio.h>
scanf("%d%lf",&x,&y);//类型不安全
printf("%d,%lf\n",x,y);//类型不安全
```
C++的输入输出：
```cpp
#include <iostream>
using namespace std;

cin>>x>>y;
cout<<x<<y;
//自动判断输入数据的类型和个数。
	   //cin为特殊类型的变量（对象），“>>”为重载的操作符
	   //cout为特殊类型的变量（对象），“<<”为重载的操作符
```
### 解决对小函数调用的低效问题
函数调用是需要额外开销的：
* 保留返回地址
* 为局部变量和形参分配空间
* 实现参数传递
* 返回时，归还空间、根据返回地址返回调用点
对一些函数体只包含一两条语句的**小函数**，函数调用的额外开销往往大于完成函数功能所需要的开销，它会使得频繁地调用这样函数的程序效率不高！
C++提供了两种解决上述问题的办法：
* 带参数的宏定义（C已有的）
* **内联函数**（C++扩充的）
#### 带参数的宏定义
带参数的宏定义是一种**编译预处理命令**，它可以实现类似函数的功能。
```c
#define max(a,b) ((a)>(b)?(a):(b))
```
在**编译之前**，编译预处理程序将对程序中宏的使用进行**文字替换**,然后交给编译程序进行编译。
例如，编译预处理程序将把程序中的
```cpp
cout << max(a,b);
```
替换成：
```cpp
cout << (((a)>(b))?(a):(b));
```
然后进行编译
**带参数的宏定义的缺点：**
1. 需要加上很多的括号，否则会出问题。
```c
#define max(x,y) x>y?x:y 
10+max(a,b)+c //将被替换成：
//10+a>b?a:b+c
//编译程序认为是：(10+a)>b?a:(b+c)
```
2. 有时会出现重复计算。
```c
max(a+1,b*2) 将被替换成：
//a+1>b*2?a+1:b*2
//a+1或b*2要计算2次
```
3. 不能进行类型检查和转换。
4. 不利于一些工具（如调试）对程序的处理。例如，在上面程序的编译结果中，max已不存在。

#### 内联函数
